<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Advanced Snake Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0c1445, #1a0033, #2d1b69);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Orbitron', monospace;
      color: #fff;
      overflow: hidden;
      padding: 10px;
      position: relative;
    }

    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .settings-panel {
      background: linear-gradient(135deg, #1a0033, #0c1445);
      border: 2px solid #00ff88;
      border-radius: 15px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
    }

    .setting-group {
      margin: 20px 0;
      text-align: left;
    }

    .setting-label {
      display: block;
      margin-bottom: 8px;
      color: #00ff88;
      font-weight: bold;
    }

    .setting-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #00ff88;
    }

    input[type="range"] {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: #333;
      outline: none;
      accent-color: #00ff88;
    }

    .range-value {
      min-width: 50px;
      text-align: right;
      color: #fff;
      font-weight: bold;
    }

    .difficulty-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .difficulty-btn {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Orbitron', monospace;
      font-size: 12px;
    }

    .difficulty-btn.active {
      background: linear-gradient(45deg, #00ff88, #00cc70);
      color: #001122;
      border-color: #00ff88;
    }

    .game-container {
      text-align: center;
      position: relative;
      width: 100%;
      max-width: 650px;
    }

    .game-header {
      margin-bottom: 15px;
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 10px;
      align-items: center;
      width: 100%;
    }

    .score-board {
      background: rgba(0, 255, 136, 0.1);
      border: 2px solid #00ff88;
      border-radius: 10px;
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .score-label {
      font-size: 9px;
      color: #00ff88;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 16px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 10px #00ff88;
    }

    .game-title {
      font-size: 28px;
      font-weight: 900;
      background: linear-gradient(45deg, #00ff88, #0080ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .level-info {
      background: rgba(0, 128, 255, 0.1);
      border: 2px solid #0080ff;
      border-radius: 10px;
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff88, #0080ff);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }

    .stats-row {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-bottom: 10px;
    }

    .stat-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 4px;
      font-size: 10px;
    }

    .stat-value {
      font-weight: 700;
      color: #00ff88;
    }

    .multiplier-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 215, 0, 0.9);
      color: #000;
      padding: 8px 12px;
      border-radius: 20px;
      font-weight: bold;
      display: none;
      z-index: 100;
      animation: multiplierPulse 1s ease-in-out infinite;
    }

    @keyframes multiplierPulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .power-up-indicator {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }

    .power-up-item {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid;
      border-radius: 8px;
      padding: 8px;
      font-size: 12px;
      font-weight: bold;
      min-width: 120px;
      text-align: center;
    }

    .power-up-shield {
      border-color: #0080ff;
      color: #0080ff;
    }

    .power-up-magnet {
      border-color: #ff6b6b;
      color: #ff6b6b;
    }

    .power-up-slow {
      border-color: #ffd700;
      color: #ffd700;
    }

    #game {
      width: 100%;
      height: auto;
      max-width: 550px;
      max-height: 550px;
      aspect-ratio: 1;
      border: 3px solid #00ff88;
      background: #001122;
      border-radius: 12px;
      box-shadow:
        0 0 30px rgba(0, 255, 136, 0.4),
        inset 0 0 20px rgba(0, 255, 136, 0.1);
      touch-action: none;
      cursor: crosshair;
    }

    .controls {
      margin-top: 15px;
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(45deg, #00ff88, #00cc70);
      border: none;
      color: #001122;
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      font-family: 'Orbitron', monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
      min-width: 70px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      box-shadow: none;
    }

    .secondary-btn {
      background: linear-gradient(45deg, #666, #888);
      color: #fff;
    }

    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      padding: 25px;
      border-radius: 15px;
      border: 2px solid #ff4444;
      text-align: center;
      display: none;
      min-width: 320px;
    }

    .game-over h2 {
      color: #ff4444;
      font-size: 28px;
      margin-bottom: 15px;
      text-shadow: 0 0 10px #ff4444;
    }

    .final-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin: 20px 0;
      font-size: 14px;
    }

    .final-stat {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 8px;
    }

    .level-up-notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 128, 255, 0.95);
      padding: 20px 30px;
      border-radius: 15px;
      border: 2px solid #0080ff;
      text-align: center;
      display: none;
      z-index: 1000;
      animation: levelUpPulse 0.5s ease-in-out;
      min-width: 280px;
    }

    .achievement-popup {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      color: #333;
      padding: 15px;
      border-radius: 10px;
      font-weight: bold;
      display: none;
      animation: achievementSlide 3s ease-in-out;
      z-index: 1001;
      max-width: 250px;
    }

    .food-bonus {
      position: absolute;
      color: #00ff88;
      font-weight: bold;
      font-size: 14px;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      z-index: 999;
    }

    .mobile-dpad {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 60px;
      border: 2px solid #00ff88;
      z-index: 1000;
    }

    .mobile-dpad.hidden {
      display: none !important;
    }

    .dpad-btn {
      position: absolute;
      width: 35px;
      height: 35px;
      background: rgba(0, 255, 136, 0.8);
      border: 1px solid #00ff88;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #000;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s ease;
    }

    .dpad-btn:active {
      background: #00ff88;
      transform: scale(0.95);
    }

    .dpad-up {
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .dpad-down {
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .dpad-left {
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    .dpad-right {
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    .settings-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0, 255, 136, 0.2);
      border: 2px solid #00ff88;
      color: #00ff88;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      min-width: auto;
      padding: 0;
    }

    .settings-btn:hover {
      background: rgba(0, 255, 136, 0.4);
      transform: rotate(90deg);
    }

    @keyframes levelUpPulse {
      0% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.1);
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    @keyframes achievementSlide {
      0% {
        transform: translateX(100%);
        opacity: 0;
      }

      15% {
        transform: translateX(0);
        opacity: 1;
      }

      85% {
        transform: translateX(0);
        opacity: 1;
      }

      100% {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes floatUp {
      0% {
        transform: translateY(0);
        opacity: 1;
      }

      100% {
        transform: translateY(-30px);
        opacity: 0;
      }
    }

    .instructions {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      font-size: 10px;
      max-width: 150px;
      z-index: 100;
    }

    /* Mobile styles */
    @media (max-width: 768px) {
      .mobile-dpad:not(.hidden) {
        display: block;
      }

      .instructions {
        display: none;
      }

      .game-header {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .game-title {
        order: -1;
        font-size: 24px;
      }

      .stats-row {
        grid-template-columns: repeat(3, 1fr);
      }

      .final-stats {
        grid-template-columns: 1fr;
      }

      .settings-panel {
        padding: 20px;
      }
    }

    @media (max-width: 480px) {
      .game-title {
        font-size: 20px;
      }

      .score-value {
        font-size: 14px;
      }

      .controls {
        gap: 6px;
      }

      button {
        padding: 6px 12px;
        font-size: 10px;
        min-width: 60px;
      }
    }
  </style>
</head>

<body>
  <button class="settings-btn" onclick="toggleSettings()">⚙</button>

  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-panel">
      <h2 style="color: #00ff88; margin-bottom: 20px;">Game Settings</h2>

      <div class="setting-group">
        <label class="setting-label">Mobile D-Pad</label>
        <div class="setting-control">
          <input type="checkbox" id="showDpad" checked>
          <label for="showDpad">Show virtual controls on mobile</label>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Game Volume</label>
        <div class="setting-control">
          <input type="range" id="volumeSlider" min="0" max="100" value="50">
          <span class="range-value" id="volumeValue">50%</span>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Particle Effects</label>
        <div class="setting-control">
          <input type="checkbox" id="particleEffects" checked>
          <label for="particleEffects">Enable visual effects</label>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Game Difficulty</label>
        <div class="difficulty-buttons">
          <button class="difficulty-btn" data-difficulty="easy">Easy</button>
          <button class="difficulty-btn active" data-difficulty="normal">Normal</button>
          <button class="difficulty-btn" data-difficulty="hard">Hard</button>
          <button class="difficulty-btn" data-difficulty="expert">Expert</button>
        </div>
      </div>

      <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
        <button onclick="applySettings()">Apply</button>
        <button class="secondary-btn" onclick="resetSettings()">Reset</button>
        <button class="secondary-btn" onclick="toggleSettings()">Close</button>
      </div>
    </div>
  </div>

  <div class="game-container">
    <div class="multiplier-indicator" id="multiplierIndicator">2x Multiplier!</div>

    <div class="power-up-indicator" id="powerUpIndicator"></div>

    <div class="game-header">
      <div class="score-board">
        <div class="score-label">Score</div>
        <div class="score-value" id="score">0</div>
        <div class="progress-bar">
          <div class="progress-fill" id="levelProgress"></div>
        </div>
      </div>

      <h1 class="game-title">SNAKE</h1>

      <div class="level-info">
        <div class="score-label">Level <span id="level">1</span></div>
        <div class="score-value" id="levelTarget">0/100</div>
      </div>
    </div>

    <div class="stats-row">
      <div class="stat-item">
        <div class="score-label">Length</div>
        <div class="stat-value" id="snakeLength">3</div>
      </div>
      <div class="stat-item">
        <div class="score-label">Speed</div>
        <div class="stat-value" id="speedDisplay">1x</div>
      </div>
      <div class="stat-item">
        <div class="score-label">Special</div>
        <div class="stat-value" id="specialFoodCount">0</div>
      </div>
      <div class="stat-item">
        <div class="score-label">Combo</div>
        <div class="stat-value" id="comboCounter">0</div>
      </div>
      <div class="stat-item">
        <div class="score-label">Best</div>
        <div class="stat-value" id="bestScore">0</div>
      </div>
    </div>

    <canvas id="game"></canvas>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <div class="final-stats">
        <div class="final-stat">
          <div class="score-label">Final Score</div>
          <div class="stat-value" id="finalScore">0</div>
        </div>
        <div class="final-stat">
          <div class="score-label">Level Reached</div>
          <div class="stat-value" id="finalLevel">1</div>
        </div>
        <div class="final-stat">
          <div class="score-label">Max Combo</div>
          <div class="stat-value" id="finalCombo">0</div>
        </div>
        <div class="final-stat">
          <div class="score-label">Special Foods</div>
          <div class="stat-value" id="finalSpecialFood">0</div>
        </div>
      </div>
      <button onclick="startNewGame()">Play Again</button>
    </div>

    <div class="level-up-notification" id="levelUpNotification">
      <h3 id="levelUpTitle">Level Up!</h3>
      <p id="levelUpMessage">You've reached level 2!</p>
      <p id="levelUpMechanic">Speed increased!</p>
    </div>

    <div class="achievement-popup" id="achievementPopup">
      <div id="achievementText">Achievement Unlocked!</div>
    </div>

    <div class="controls">
      <button onclick="startNewGame()" id="startBtn">New Game</button>
      <button onclick="pauseGame()" id="pauseBtn">Pause</button>
      <button onclick="resumeGame()" id="resumeBtn">Resume</button>
    </div>
  </div>

  <div class="mobile-dpad" id="mobileDpad">
    <div class="dpad-btn dpad-up" data-dir="up">↑</div>
    <div class="dpad-btn dpad-down" data-dir="down">↓</div>
    <div class="dpad-btn dpad-left" data-dir="left">←</div>
    <div class="dpad-btn dpad-right" data-dir="right">→</div>
  </div>

  <div class="instructions">
    <h3>Controls</h3>
    <p>↑↓←→ Arrow Keys</p>
    <p>WASD Keys</p>
    <br>
    <h3>Food Types</h3>
    <p>🔴 Normal (+10)</p>
    <p>🟠 Big Food (+25)</p>
    <p>💎 Bonus Food (+50)</p>
    <p>⚡ Power Food (+100)</p>
    <p>🎯 Portal Food</p>
    <br>
    <h3>Power-ups</h3>
    <p>🛡️ Shield (3 hits)</p>
    <p>🧲 Magnet (5s)</p>
    <p>⏳ Slow Motion (3s)</p>
    <br>
    <h3>Features</h3>
    <p>• Combo multipliers</p>
    <p>• Advanced obstacles</p>
    <p>• Portal teleportation</p>
    <p>• Dynamic difficulty</p>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Settings
    let gameSettings = {
      showDpad: true,
      volume: 50,
      particleEffects: true,
      difficulty: 'normal'
    };

    // Load settings from localStorage
    const savedSettings = localStorage.getItem('snakeGameSettings');
    if (savedSettings) {
      gameSettings = { ...gameSettings, ...JSON.parse(savedSettings) };
    }

    // UI Elements
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const levelTargetElement = document.getElementById('levelTarget');
    const levelProgressElement = document.getElementById('levelProgress');
    const snakeLengthElement = document.getElementById('snakeLength');
    const speedDisplayElement = document.getElementById('speedDisplay');
    const specialFoodCountElement = document.getElementById('specialFoodCount');
    const comboCounterElement = document.getElementById('comboCounter');
    const bestScoreElement = document.getElementById('bestScore');
    const gameOverElement = document.getElementById('gameOver');
    const levelUpElement = document.getElementById('levelUpNotification');
    const achievementElement = document.getElementById('achievementPopup');
    const multiplierElement = document.getElementById('multiplierIndicator');
    const powerUpElement = document.getElementById('powerUpIndicator');

    const gridSize = 20;
    let gridCount;
    let canvasSize;

    // Game State
    let snake = [];
    let foods = [];
    let obstacles = [];
    let portals = [];
    let particles = [];
    let powerUps = [];
    let dx = 0;
    let dy = 0;
    let score = 0;
    let level = 1;
    let levelProgress = 0;
    let gameRunning = false;
    let gamePaused = false;
    let gameLoop = null;
    let baseSpeed = 250;
    let currentSpeed = baseSpeed;
    let specialFoodEaten = 0;
    let bestScore = localStorage.getItem('snakeBestScore') || 0;
    let maxCombo = 0;

    // Advanced Game Mechanics
    let snakeDirection = 'right';
    let nextDirection = 'right';
    let comboCount = 0;
    let comboMultiplier = 1;
    let lastFoodTime = Date.now();
    let shieldHits = 0;
    let magnetActive = false;
    let magnetTimer = 0;
    let slowMotionActive = false;
    let slowMotionTimer = 0;
    let achievements = JSON.parse(localStorage.getItem('snakeAchievements') || '{}');

    // Difficulty settings
    const difficultySettings = {
      easy: { wallCollisionLevel: 15, speedMultiplier: 0.8, obstacleChance: 0.02 },
      normal: { wallCollisionLevel: 10, speedMultiplier: 1.0, obstacleChance: 0.04 },
      hard: { wallCollisionLevel: 6, speedMultiplier: 1.3, obstacleChance: 0.06 },
      expert: { wallCollisionLevel: 3, speedMultiplier: 1.6, obstacleChance: 0.08 }
    };

    // Food types - enhanced
    const FOOD_TYPES = {
      NORMAL: { points: 10, color: '#ff6b6b', size: 0.8, chance: 0.5 },
      BIG: { points: 25, color: '#ff9500', size: 1.2, chance: 0.25 },
      BONUS: { points: 50, color: '#00d2ff', size: 1.0, chance: 0.15 },
      POWER: { points: 100, color: '#ffd700', size: 1.4, chance: 0.08 },
      PORTAL: { points: 75, color: '#9b59b6', size: 1.1, chance: 0.02 }
    };

    function applySettings() {
      const showDpad = document.getElementById('showDpad').checked;
      const volume = document.getElementById('volumeSlider').value;
      const particleEffects = document.getElementById('particleEffects').checked;
      const difficulty = document.querySelector('.difficulty-btn.active').dataset.difficulty;

      gameSettings = { showDpad, volume: parseInt(volume), particleEffects, difficulty };
      localStorage.setItem('snakeGameSettings', JSON.stringify(gameSettings));

      // Apply mobile D-pad setting
      const mobileDpad = document.getElementById('mobileDpad');
      if (showDpad) {
        mobileDpad.classList.remove('hidden');
      } else {
        mobileDpad.classList.add('hidden');
      }

      // Apply difficulty
      baseSpeed = 250 / difficultySettings[difficulty].speedMultiplier;

      toggleSettings();
    }

    function resetSettings() {
      document.getElementById('showDpad').checked = true;
      document.getElementById('volumeSlider').value = 50;
      document.getElementById('volumeValue').textContent = '50%';
      document.getElementById('particleEffects').checked = true;

      document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector('[data-difficulty="normal"]').classList.add('active');
    }

    function toggleSettings() {
      const overlay = document.getElementById('settingsOverlay');
      const isVisible = overlay.style.display === 'flex';
      overlay.style.display = isVisible ? 'none' : 'flex';

      if (!isVisible) {
        // Load current settings into UI
        document.getElementById('showDpad').checked = gameSettings.showDpad;
        document.getElementById('volumeSlider').value = gameSettings.volume;
        document.getElementById('volumeValue').textContent = gameSettings.volume + '%';
        document.getElementById('particleEffects').checked = gameSettings.particleEffects;

        document.querySelectorAll('.difficulty-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.difficulty === gameSettings.difficulty);
        });
      }
    }

    function resizeCanvas() {
      const container = canvas.parentElement;
      const maxSize = Math.min(
        window.innerWidth - 20,
        window.innerHeight - 250,
        550
      );

      canvasSize = Math.floor(maxSize / gridSize) * gridSize;
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      gridCount = canvasSize / gridSize;

      if (gameRunning) {
        render();
      }
    }

    function initGame() {
      resizeCanvas();

      const startX = Math.floor(gridCount / 2);
      const startY = Math.floor(gridCount / 2);

      snake = [
        { x: startX, y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];

      foods = [];
      obstacles = [];
      portals = [];
      particles = [];
      powerUps = [];
      dx = 1;
      dy = 0;
      score = 0;
      level = 1;
      levelProgress = 0;
      specialFoodEaten = 0;
      comboCount = 0;
      comboMultiplier = 1;
      maxCombo = 0;
      shieldHits = 0;
      magnetActive = false;
      magnetTimer = 0;
      slowMotionActive = false;
      slowMotionTimer = 0;
      currentSpeed = baseSpeed;
      snakeDirection = 'right';
      nextDirection = 'right';
      lastFoodTime = Date.now();

      updateUI();
      generateFood();
      updatePowerUpDisplay();
    }

    function generateFood() {
      // Keep 1-2 foods on screen
      if (foods.length >= 2) return;

      let foodType = 'NORMAL';
      const rand = Math.random();

      // Enhanced food probability system
      if (level >= 5 && rand < 0.05) foodType = 'PORTAL';
      else if (level >= 4 && rand < 0.12) foodType = 'POWER';
      else if (level >= 3 && rand < 0.25) foodType = 'BONUS';
      else if (level >= 2 && rand < 0.45) foodType = 'BIG';

      let newFood;
      let attempts = 0;
      do {
        newFood = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount),
          type: foodType,
          spawnTime: Date.now(),
          timeLimit: foodType === 'NORMAL' ? null :
            foodType === 'BIG' ? 10000 :
              foodType === 'BONUS' ? 8000 :
                foodType === 'POWER' ? 6000 :
                  foodType === 'PORTAL' ? 12000 : null
        };
        attempts++;
      } while (attempts < 50 && (
        snake.some(part => part.x === newFood.x && part.y === newFood.y) ||
        obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y)
      ));

      if (attempts < 50) {
        foods.push(newFood);
      }
    }

    function generateObstacle() {
      if (level < 3) return;

      const difficulty = difficultySettings[gameSettings.difficulty];
      if (Math.random() > difficulty.obstacleChance) return;

      let newObstacle;
      let attempts = 0;
      do {
        newObstacle = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount),
          type: Math.random() < 0.7 ? 'block' : 'spike',
          spawnTime: Date.now()
        };
        attempts++;
      } while (attempts < 20 && (
        snake.some(part => part.x === newObstacle.x && part.y === newObstacle.y) ||
        foods.some(food => food.x === newObstacle.x && food.y === newObstacle.y) ||
        obstacles.some(obs => obs.x === newObstacle.x && obs.y === newObstacle.y)
      ));

      if (attempts < 20) {
        obstacles.push(newObstacle);
      }
    }

    function generatePortal() {
      if (portals.length >= 2 || level < 5) return;

      for (let i = 0; i < 2; i++) {
        let portal;
        let attempts = 0;
        do {
          portal = {
            x: Math.floor(Math.random() * gridCount),
            y: Math.floor(Math.random() * gridCount),
            id: i,
            cooldown: 0
          };
          attempts++;
        } while (attempts < 20 && (
          snake.some(part => part.x === portal.x && part.y === portal.y) ||
          foods.some(food => food.x === portal.x && food.y === portal.y) ||
          obstacles.some(obs => obs.x === portal.x && obs.y === portal.y) ||
          portals.some(p => p.x === portal.x && p.y === portal.y)
        ));

        if (attempts < 20) {
          portals.push(portal);
        }
      }
    }

    function createParticle(x, y, color, velocity = null) {
      if (!gameSettings.particleEffects) return;

      const particle = {
        x: x * gridSize + gridSize / 2,
        y: y * gridSize + gridSize / 2,
        vx: velocity ? velocity.x : (Math.random() - 0.5) * 4,
        vy: velocity ? velocity.y : (Math.random() - 0.5) * 4,
        life: 1.0,
        decay: 0.02 + Math.random() * 0.02,
        color: color,
        size: 2 + Math.random() * 3
      };
      particles.push(particle);
    }

    function updateParticles() {
      particles = particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= particle.decay;
        particle.size *= 0.98;
        return particle.life > 0 && particle.size > 0.1;
      });
    }

    function drawParticles() {
      particles.forEach(particle => {
        ctx.save();
        ctx.globalAlpha = particle.life;
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function drawSnakeSegment(x, y, isHead = false, direction = 'right', bodyIndex = 0) {
      const pixelX = x * gridSize;
      const pixelY = y * gridSize;
      const padding = 1;

      if (isHead) {
        // Enhanced head with shield effect
        const gradient = ctx.createRadialGradient(
          pixelX + gridSize / 2, pixelY + gridSize / 2, 0,
          pixelX + gridSize / 2, pixelY + gridSize / 2, gridSize / 2
        );

        if (shieldHits > 0) {
          gradient.addColorStop(0, '#00bfff');
          gradient.addColorStop(0.7, '#0080ff');
          gradient.addColorStop(1, '#004080');
        } else {
          gradient.addColorStop(0, '#7fff00');
          gradient.addColorStop(0.7, '#32cd32');
          gradient.addColorStop(1, '#228b22');
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(pixelX + padding, pixelY + padding, gridSize - padding * 2, gridSize - padding * 2);

        // Shield visual effect
        if (shieldHits > 0) {
          ctx.strokeStyle = '#00bfff';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.strokeRect(pixelX - 2, pixelY - 2, gridSize + 4, gridSize + 4);
          ctx.setLineDash([]);
        }

        // Eyes based on direction
        ctx.fillStyle = '#000';
        const eyeSize = 3;
        const eyeOffset = 5;

        switch (direction) {
          case 'right':
            ctx.fillRect(pixelX + gridSize - eyeOffset, pixelY + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(pixelX + gridSize - eyeOffset, pixelY + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
            break;
          case 'left':
            ctx.fillRect(pixelX + eyeOffset - eyeSize, pixelY + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(pixelX + eyeOffset - eyeSize, pixelY + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
            break;
          case 'up':
            ctx.fillRect(pixelX + eyeOffset, pixelY + eyeOffset - eyeSize, eyeSize, eyeSize);
            ctx.fillRect(pixelX + gridSize - eyeOffset - eyeSize, pixelY + eyeOffset - eyeSize, eyeSize, eyeSize);
            break;
          case 'down':
            ctx.fillRect(pixelX + eyeOffset, pixelY + gridSize - eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(pixelX + gridSize - eyeOffset - eyeSize, pixelY + gridSize - eyeOffset, eyeSize, eyeSize);
            break;
        }
      } else {
        // Enhanced body segments
        const intensity = Math.max(0.3, 1 - (bodyIndex * 0.03));
        const hue = magnetActive ? 200 : 120; // Blue tint when magnet is active

        ctx.fillStyle = `hsla(${hue}, 70%, 40%, ${intensity})`;
        ctx.fillRect(pixelX + padding, pixelY + padding, gridSize - padding * 2, gridSize - padding * 2);

        // Scale pattern
        if (bodyIndex % 3 === 0) {
          ctx.fillStyle = `hsla(${hue}, 50%, 20%, ${intensity * 0.5})`;
          ctx.fillRect(pixelX + 4, pixelY + 4, gridSize - 8, gridSize - 8);
        }
      }
    }

    function drawFood(food) {
      const pixelX = food.x * gridSize;
      const pixelY = food.y * gridSize;
      const foodData = FOOD_TYPES[food.type];
      let size = gridSize * foodData.size;

      // Time-based effects
      let timeRatio = 1;
      if (food.timeLimit) {
        const elapsed = Date.now() - food.spawnTime;
        timeRatio = Math.max(0, 1 - (elapsed / food.timeLimit));

        if (timeRatio < 0.3) {
          const flashRate = timeRatio < 0.15 ? 12 : 6;
          const flash = Math.sin(Date.now() * flashRate * 0.01);
          if (flash < 0) return;
        }
      }

      // Magnet effect
      if (magnetActive && food.type !== 'PORTAL') {
        const head = snake[0];
        const distance = Math.sqrt(
          Math.pow(food.x - head.x, 2) + Math.pow(food.y - head.y, 2)
        );

        if (distance <= 4) {
          const angle = Math.atan2(head.y - food.y, head.x - food.x);
          const pullStrength = 0.3;
          food.x += Math.cos(angle) * pullStrength;
          food.y += Math.sin(angle) * pullStrength;

          // Create magnet particles
          if (Math.random() < 0.3) {
            createParticle(food.x, food.y, '#ff6b6b', {
              x: Math.cos(angle) * 2,
              y: Math.sin(angle) * 2
            });
          }
        }
      }

      // Enhanced animations
      const pulse = Math.sin((Date.now() - food.spawnTime) * 0.008) * 0.15 + 0.85;
      const currentSize = size * pulse * timeRatio;

      // Food gradient with enhanced effects
      const gradient = ctx.createRadialGradient(
        pixelX + gridSize / 2, pixelY + gridSize / 2, 0,
        pixelX + gridSize / 2, pixelY + gridSize / 2, currentSize / 2
      );

      switch (food.type) {
        case 'NORMAL':
          gradient.addColorStop(0, '#ff6b6b');
          gradient.addColorStop(0.7, '#ee5a24');
          gradient.addColorStop(1, '#c44569');
          break;
        case 'BIG':
          gradient.addColorStop(0, '#ff9500');
          gradient.addColorStop(0.7, '#ff6b00');
          gradient.addColorStop(1, '#cc5500');
          break;
        case 'BONUS':
          gradient.addColorStop(0, '#00d2ff');
          gradient.addColorStop(0.5, '#0099cc');
          gradient.addColorStop(1, '#006699');
          break;
        case 'POWER':
          gradient.addColorStop(0, '#ffd700');
          gradient.addColorStop(0.5, '#ffaa00');
          gradient.addColorStop(1, '#cc8800');
          break;
        case 'PORTAL':
          gradient.addColorStop(0, '#e74c3c');
          gradient.addColorStop(0.5, '#9b59b6');
          gradient.addColorStop(1, '#2c3e50');
          break;
      }

      ctx.save();
      ctx.globalAlpha = timeRatio;
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(pixelX + gridSize / 2, pixelY + gridSize / 2, currentSize / 2, 0, Math.PI * 2);
      ctx.fill();

      // Special effects for each food type
      if (food.type === 'POWER') {
        // Lightning effect for power food
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = timeRatio * 0.8;
        const lightningOffset = Math.sin(Date.now() * 0.02) * 3;
        ctx.beginPath();
        ctx.arc(pixelX + gridSize / 2 + lightningOffset, pixelY + gridSize / 2, currentSize / 2, 0, Math.PI * 2);
        ctx.stroke();
      } else if (food.type === 'PORTAL') {
        // Swirling portal effect
        ctx.save();
        ctx.translate(pixelX + gridSize / 2, pixelY + gridSize / 2);
        ctx.rotate(Date.now() * 0.005);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(0, 0, (currentSize / 2) - i * 3, 0, Math.PI);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Time limit indicator ring
      if (food.timeLimit && timeRatio < 0.8) {
        const elapsed = Date.now() - food.spawnTime;
        const remainingRatio = Math.max(0, 1 - (elapsed / food.timeLimit));

        ctx.strokeStyle = remainingRatio > 0.3 ? '#ffaa00' : '#ff4444';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(
          pixelX + gridSize / 2,
          pixelY + gridSize / 2,
          currentSize / 2 + 5,
          -Math.PI / 2,
          -Math.PI / 2 + (remainingRatio * Math.PI * 2)
        );
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawObstacle(obstacle) {
      const pixelX = obstacle.x * gridSize;
      const pixelY = obstacle.y * gridSize;
      const padding = 2;

      ctx.save();

      if (obstacle.type === 'spike') {
        // Animated spikes
        ctx.fillStyle = '#ff4444';
        ctx.strokeStyle = '#aa0000';
        ctx.lineWidth = 2;

        const centerX = pixelX + gridSize / 2;
        const centerY = pixelY + gridSize / 2;
        const size = gridSize / 2 - padding;

        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * size;
          const y = centerY + Math.sin(angle) * size;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else {
        // Static blocks
        ctx.fillStyle = '#666';
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.fillRect(pixelX + padding, pixelY + padding, gridSize - padding * 2, gridSize - padding * 2);
        ctx.strokeRect(pixelX + padding, pixelY + padding, gridSize - padding * 2, gridSize - padding * 2);
      }

      ctx.restore();
    }

    function drawPortal(portal) {
      const pixelX = portal.x * gridSize;
      const pixelY = portal.y * gridSize;
      const centerX = pixelX + gridSize / 2;
      const centerY = pixelY + gridSize / 2;

      ctx.save();

      // Portal animation
      const time = Date.now() * 0.01;
      const baseRadius = gridSize / 3;

      // Outer ring
      ctx.strokeStyle = portal.cooldown > 0 ? '#666' : '#9b59b6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(centerX, centerY, baseRadius + Math.sin(time) * 2, 0, Math.PI * 2);
      ctx.stroke();

      // Inner swirl
      if (portal.cooldown <= 0) {
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          ctx.beginPath();
          const angle = time + (i * Math.PI / 2);
          const startAngle = angle;
          const endAngle = angle + Math.PI / 3;
          ctx.arc(centerX, centerY, baseRadius * 0.7, startAngle, endAngle);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawBackground() {
      // Enhanced animated background
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dynamic grid with level-based intensity
      const time = Date.now() * 0.001;
      const intensity = 0.03 + (level * 0.005);
      ctx.strokeStyle = `rgba(0, 255, 136, ${intensity + Math.sin(time) * 0.01})`;
      ctx.lineWidth = 1;

      for (let i = 0; i <= gridCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }

      // Level-based background effects
      if (level >= 5) {
        ctx.save();
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = `hsl(${(time * 50) % 360}, 50%, 30%)`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
    }

    function updateGame() {
      if (!gameRunning || gamePaused) return;

      // Update timers
      if (magnetActive) {
        magnetTimer -= currentSpeed;
        if (magnetTimer <= 0) {
          magnetActive = false;
        }
      }

      if (slowMotionActive) {
        slowMotionTimer -= currentSpeed;
        if (slowMotionTimer <= 0) {
          slowMotionActive = false;
        }
      }

      // Update portals
      portals.forEach(portal => {
        if (portal.cooldown > 0) {
          portal.cooldown -= currentSpeed;
        }
      });

      // Update combo multiplier
      const timeSinceLastFood = Date.now() - lastFoodTime;
      if (timeSinceLastFood > 3000) {
        comboCount = 0;
        comboMultiplier = 1;
        multiplierElement.style.display = 'none';
      }

      // Update direction
      snakeDirection = nextDirection;
      dx = 0;
      dy = 0;

      switch (snakeDirection) {
        case 'right': dx = 1; break;
        case 'left': dx = -1; break;
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
      }

      const head = { x: snake[0].x + dx, y: snake[0].y + dy };

      // Wall collision logic with difficulty-based timing
      const difficulty = difficultySettings[gameSettings.difficulty];
      if (level <= difficulty.wallCollisionLevel) {
        // Wall wrapping
        if (head.x < 0) head.x = gridCount - 1;
        if (head.x >= gridCount) head.x = 0;
        if (head.y < 0) head.y = gridCount - 1;
        if (head.y >= gridCount) head.y = 0;
      } else {
        // Wall collision
        if (head.x < 0 || head.x >= gridCount || head.y < 0 || head.y >= gridCount) {
          if (shieldHits > 0) {
            shieldHits--;
            // Bounce back
            head.x = snake[0].x;
            head.y = snake[0].y;
            createParticle(head.x, head.y, '#00bfff');
            showFoodBonus(head.x * gridSize, head.y * gridSize, 'SHIELD!');
          } else {
            gameOver();
            return;
          }
        }
      }

      // Obstacle collision
      const hitObstacle = obstacles.find(obs => obs.x === head.x && obs.y === head.y);
      if (hitObstacle) {
        if (hitObstacle.type === 'spike') {
          if (shieldHits > 0) {
            shieldHits--;
            obstacles = obstacles.filter(obs => obs !== hitObstacle);
            createParticle(head.x, head.y, '#ff4444');
            showFoodBonus(head.x * gridSize, head.y * gridSize, 'SPIKE DESTROYED!');
          } else {
            gameOver();
            return;
          }
        } else {
          // Block - always kills
          if (shieldHits > 0) {
            shieldHits--;
            head.x = snake[0].x;
            head.y = snake[0].y;
            createParticle(head.x, head.y, '#666');
          } else {
            gameOver();
            return;
          }
        }
      }

      // Portal collision
      const hitPortal = portals.find(portal => portal.x === head.x && portal.y === head.y && portal.cooldown <= 0);
      if (hitPortal) {
        const otherPortal = portals.find(portal => portal !== hitPortal);
        if (otherPortal) {
          head.x = otherPortal.x;
          head.y = otherPortal.y;
          hitPortal.cooldown = 2000;
          otherPortal.cooldown = 2000;
          createParticle(head.x, head.y, '#9b59b6');
          showFoodBonus(head.x * gridSize, head.y * gridSize, 'PORTAL!');
        }
      }

      // Self collision
      if (snake.some(part => part.x === head.x && part.y === head.y)) {
        if (shieldHits > 0) {
          shieldHits--;
          head.x = snake[0].x;
          head.y = snake[0].y;
          createParticle(head.x, head.y, '#00bfff');
        } else {
          gameOver();
          return;
        }
      }

      snake.unshift(head);

      // Food collision and management
      let foodEaten = false;
      const currentTime = Date.now();

      foods = foods.filter(food => {
        // Check if food expired
        if (food.timeLimit && (currentTime - food.spawnTime) > food.timeLimit) {
          createParticle(food.x, food.y, '#666');
          return false;
        }

        // Check collision
        if (Math.floor(head.x) === Math.floor(food.x) && Math.floor(head.y) === Math.floor(food.y)) {
          const foodData = FOOD_TYPES[food.type];
          let points = foodData.points;

          // Apply combo multiplier
          if (comboMultiplier > 1) {
            points *= comboMultiplier;
          }

          // Apply level multiplier
          points = Math.floor(points * (1 + (level - 1) * 0.1));

          score += points;
          levelProgress += Math.min(points, 50); // Cap level progress per food

          // Handle special food effects
          if (food.type === 'POWER') {
            // Grant random power-up
            const powerTypes = ['shield', 'magnet', 'slow'];
            const randomPower = powerTypes[Math.floor(Math.random() * powerTypes.length)];
            activatePowerUp(randomPower);
          } else if (food.type === 'PORTAL') {
            // Teleport effect already handled above
            generatePortal();
          }

          if (food.type !== 'NORMAL') {
            specialFoodEaten++;
          }

          // Update combo system
          comboCount++;
          maxCombo = Math.max(maxCombo, comboCount);
          lastFoodTime = currentTime;

          if (comboCount >= 3) {
            comboMultiplier = Math.min(3, Math.floor(comboCount / 3) + 1);
            multiplierElement.textContent = `${comboMultiplier}x Combo!`;
            multiplierElement.style.display = 'block';
          }

          // Create food particles
          createParticle(food.x, food.y, foodData.color);
          showFoodBonus(food.x * gridSize, food.y * gridSize, `+${points}`);

          foodEaten = true;
          checkAchievements();
          return false;
        }
        return true;
      });

      if (!foodEaten) {
        snake.pop();
      }

      // Level progression
      const requiredForNextLevel = 100 + (level - 1) * 25; // Increasing requirements
      if (levelProgress >= requiredForNextLevel) {
        level++;
        levelProgress = 0;

        // Speed adjustment with slow motion consideration
        const baseSpeedReduction = (level - 1) * 15;
        const difficultyMultiplier = difficultySettings[gameSettings.difficulty].speedMultiplier;
        currentSpeed = Math.max(60, (baseSpeed - baseSpeedReduction) / difficultyMultiplier);

        if (slowMotionActive) {
          currentSpeed *= 1.5;
        }

        showLevelUpNotification();

        // Generate level content
        if (level >= 3 && obstacles.length < level) {
          generateObstacle();
        }
        if (level >= 5 && portals.length === 0) {
          generatePortal();
        }

        restartGameLoop();
      }

      // Generate new food
      if (foods.length === 0 || (foods.length === 1 && Math.random() < 0.1)) {
        generateFood();
      }

      // Occasionally generate obstacles
      if (level >= 3 && Math.random() < 0.002) {
        generateObstacle();
      }

      updateParticles();
      updateUI();
      render();
    }

    function activatePowerUp(type) {
      switch (type) {
        case 'shield':
          shieldHits = 3;
          showAchievement('Shield Activated! 3 hits protected');
          break;
        case 'magnet':
          magnetActive = true;
          magnetTimer = 5000;
          showAchievement('Magnet Active! Food attraction for 5s');
          break;
        case 'slow':
          slowMotionActive = true;
          slowMotionTimer = 3000;
          currentSpeed *= 1.5;
          restartGameLoop();
          showAchievement('Slow Motion! Time slowed for 3s');
          break;
      }
      updatePowerUpDisplay();
    }

    function updatePowerUpDisplay() {
      const indicator = powerUpElement;
      indicator.innerHTML = '';

      if (shieldHits > 0) {
        const shield = document.createElement('div');
        shield.className = 'power-up-item power-up-shield';
        shield.textContent = `🛡️ Shield: ${shieldHits}`;
        indicator.appendChild(shield);
      }

      if (magnetActive) {
        const magnet = document.createElement('div');
        magnet.className = 'power-up-item power-up-magnet';
        const timeLeft = Math.ceil(magnetTimer / 1000);
        magnet.textContent = `🧲 Magnet: ${timeLeft}s`;
        indicator.appendChild(magnet);
      }

      if (slowMotionActive) {
        const slow = document.createElement('div');
        slow.className = 'power-up-item power-up-slow';
        const timeLeft = Math.ceil(slowMotionTimer / 1000);
        slow.textContent = `⏳ Slow: ${timeLeft}s`;
        indicator.appendChild(slow);
      }
    }

    function showFoodBonus(x, y, points) {
      const bonus = document.createElement('div');
      bonus.className = 'food-bonus';
      bonus.textContent = points;
      bonus.style.left = x + 'px';
      bonus.style.top = y + 'px';

      document.body.appendChild(bonus);
      setTimeout(() => bonus.remove(), 1000);
    }

    function checkAchievements() {
      const newAchievements = [];

      // Score-based achievements
      if (score >= 200 && !achievements.century) {
        achievements.century = true;
        newAchievements.push("First Milestone - Scored 200 points!");
      }

      if (score >= 1000 && !achievements.highScore) {
        achievements.highScore = true;
        newAchievements.push("High Scorer - Reached 1000 points!");
      }

      if (score >= 2500 && !achievements.master) {
        achievements.master = true;
        newAchievements.push("Snake Master - Reached 2500 points!");
      }

      if (score >= 5000 && !achievements.legend) {
        achievements.legend = true;
        newAchievements.push("Legend - Reached 5000 points!");
      }

      // Length-based achievements
      if (snake.length >= 15 && !achievements.growing) {
        achievements.growing = true;
        newAchievements.push("Growing Strong - Length of 15!");
      }

      if (snake.length >= 30 && !achievements.longSnake) {
        achievements.longSnake = true;
        newAchievements.push("Long Snake - Length of 30!");
      }

      if (snake.length >= 50 && !achievements.giant) {
        achievements.giant = true;
        newAchievements.push("Giant Snake - Length of 50!");
      }

      // Level-based achievements
      if (level >= 8 && !achievements.levelEight) {
        achievements.levelEight = true;
        newAchievements.push("Speed Demon - Reached Level 8!");
      }

      if (level >= 15 && !achievements.levelFifteen) {
        achievements.levelFifteen = true;
        newAchievements.push("Elite Player - Reached Level 15!");
      }

      if (level >= 25 && !achievements.levelTwentyFive) {
        achievements.levelTwentyFive = true;
        newAchievements.push("Snake God - Reached Level 25!");
      }

      // Special achievements
      if (comboCount >= 5 && !achievements.comboMaster) {
        achievements.comboMaster = true;
        newAchievements.push("Combo Master - 5x combo achieved!");
      }

      if (specialFoodEaten >= 10 && !achievements.specialist) {
        achievements.specialist = true;
        newAchievements.push("Specialist - Ate 10 special foods!");
      }

      if (shieldHits > 0 && !achievements.survivor) {
        achievements.survivor = true;
        newAchievements.push("Survivor - Used shield protection!");
      }

      if (magnetActive && !achievements.magnetic) {
        achievements.magnetic = true;
        newAchievements.push("Magnetic Personality - Used magnet power!");
      }

      // Save achievements
      localStorage.setItem('snakeAchievements', JSON.stringify(achievements));

      // Show new achievements
      newAchievements.forEach((achievement, index) => {
        setTimeout(() => showAchievement(achievement), index * 500);
      });
    }

    function showAchievement(text) {
      document.getElementById('achievementText').textContent = text;
      achievementElement.style.display = 'block';
      setTimeout(() => {
        achievementElement.style.display = 'none';
      }, 3000);
    }

    function render() {
      drawBackground();

      // Draw portals
      portals.forEach(portal => drawPortal(portal));

      // Draw obstacles
      obstacles.forEach(obstacle => drawObstacle(obstacle));

      // Draw all foods
      foods.forEach(food => {
        ctx.save();
        if (food.type === 'BONUS' || food.type === 'POWER') {
          const pulse = Math.sin(Date.now() * 0.015) * 0.3 + 0.7;
          ctx.globalAlpha = pulse;
        }
        drawFood(food);
        ctx.restore();
      });

      // Draw particles
      drawParticles();

      // Draw snake
      snake.forEach((part, index) => {
        drawSnakeSegment(
          part.x,
          part.y,
          index === 0,
          snakeDirection,
          index
        );
      });

      // Enhanced level warning overlay
      const difficulty = difficultySettings[gameSettings.difficulty];
      if (level > difficulty.wallCollisionLevel) {
        ctx.save();
        ctx.strokeStyle = shieldHits > 0 ? '#0080ff' : '#ff4444';
        ctx.lineWidth = 4;
        ctx.setLineDash([15, 10]);
        ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);
        ctx.restore();
      }
    }

    function gameOver() {
      gameRunning = false;
      gamePaused = false;
      clearInterval(gameLoop);

      // Create explosion effect
      if (gameSettings.particleEffects) {
        for (let i = 0; i < 20; i++) {
          createParticle(snake[0].x, snake[0].y, '#ff4444', {
            x: (Math.random() - 0.5) * 8,
            y: (Math.random() - 0.5) * 8
          });
        }
      }

      // Update best score
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('snakeBestScore', bestScore);
        showAchievement("New High Score! 🏆");
      }

      // Update final stats
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalLevel').textContent = level;
      document.getElementById('finalCombo').textContent = maxCombo;
      document.getElementById('finalSpecialFood').textContent = specialFoodEaten;

      gameOverElement.style.display = 'block';

      // Game over screen effect
      ctx.save();
      ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function startNewGame() {
      gameOverElement.style.display = 'none';
      levelUpElement.style.display = 'none';
      multiplierElement.style.display = 'none';
      initGame();
      gameRunning = true;
      gamePaused = false;
      restartGameLoop();
      render();

      document.getElementById('startBtn').textContent = 'Restart';
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('resumeBtn').disabled = true;
    }

    function pauseGame() {
      if (gameRunning && !gamePaused) {
        gamePaused = true;
        clearInterval(gameLoop);
        document.getElementById('pauseBtn').disabled = true;
        document.getElementById('resumeBtn').disabled = false;

        // Enhanced pause overlay
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
        ctx.font = 'bold 14px Orbitron';
        ctx.fillText('Press Resume to continue', canvas.width / 2, canvas.height / 2 + 40);
        ctx.restore();
      }
    }

    function resumeGame() {
      if (gameRunning && gamePaused) {
        gamePaused = false;
        restartGameLoop();
        document.getElementById('pauseBtn').disabled = false;
        document.getElementById('resumeBtn').disabled = true;
      }
    }

    function restartGameLoop() {
      if (gameLoop) clearInterval(gameLoop);
      const effectiveSpeed = slowMotionActive ? currentSpeed * 1.5 : currentSpeed;
      gameLoop = setInterval(updateGame, effectiveSpeed);
    }

    function updateUI() {
      scoreElement.textContent = score.toLocaleString();
      levelElement.textContent = level;
      const requiredForNextLevel = 100 + (level - 1) * 25;
      levelTargetElement.textContent = `${levelProgress}/${requiredForNextLevel}`;
      snakeLengthElement.textContent = snake.length;
      speedDisplayElement.textContent = `${(baseSpeed / currentSpeed).toFixed(1)}x`;
      specialFoodCountElement.textContent = specialFoodEaten;
      comboCounterElement.textContent = comboCount;
      bestScoreElement.textContent = parseInt(bestScore).toLocaleString();

      // Update progress bar
      const progressPercent = (levelProgress / requiredForNextLevel) * 100;
      levelProgressElement.style.width = progressPercent + '%';

      updatePowerUpDisplay();
    }

    function showLevelUpNotification() {
      const wasRunning = gameRunning;
      const wasPaused = gamePaused;
      gameRunning = false;

      document.getElementById('levelUpTitle').textContent = `Level ${level}!`;
      document.getElementById('levelUpMessage').textContent = `You've reached level ${level}!`;

      const difficulty = difficultySettings[gameSettings.difficulty];
      let mechanicText = `Speed: ${(baseSpeed / currentSpeed).toFixed(1)}x`;

      if (level === difficulty.wallCollisionLevel + 1) {
        mechanicText = '⚠️ Wall collision enabled! ' + mechanicText;
      } else if (level === 3) {
        mechanicText = '🚧 Obstacles appear! ' + mechanicText;
      } else if (level === 5) {
        mechanicText = '🌀 Portals activated! ' + mechanicText;
      }

      document.getElementById('levelUpMechanic').textContent = mechanicText;
      levelUpElement.style.display = 'block';

      setTimeout(() => {
        levelUpElement.style.display = 'none';
        gameRunning = wasRunning;
        gamePaused = wasPaused;
      }, 2500);
    }

    // Enhanced keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        toggleSettings();
        return;
      }

      if (!gameRunning || gamePaused) {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          if (gamePaused) resumeGame();
          else if (!gameRunning) startNewGame();
          return;
        }
        return;
      }

      const key = e.key.toLowerCase();
      let newDirection = null;

      switch (key) {
        case 'arrowup':
        case 'w':
          if (snakeDirection !== 'down') newDirection = 'up';
          break;
        case 'arrowdown':
        case 's':
          if (snakeDirection !== 'up') newDirection = 'down';
          break;
        case 'arrowleft':
        case 'a':
          if (snakeDirection !== 'right') newDirection = 'left';
          break;
        case 'arrowright':
        case 'd':
          if (snakeDirection !== 'left') newDirection = 'right';
          break;
        case ' ':
        case 'p':
          e.preventDefault();
          pauseGame();
          break;
      }

      if (newDirection) {
        nextDirection = newDirection;
        e.preventDefault();
      }
    });

    // Settings event listeners
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      document.getElementById('volumeValue').textContent = e.target.value + '%';
    });

    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Mobile D-pad controls
    document.querySelectorAll('.dpad-btn').forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!gameRunning || gamePaused) return;

        const direction = btn.dataset.dir;
        let newDirection = null;

        switch (direction) {
          case 'up':
            if (snakeDirection !== 'down') newDirection = 'up';
            break;
          case 'down':
            if (snakeDirection !== 'up') newDirection = 'down';
            break;
          case 'left':
            if (snakeDirection !== 'right') newDirection = 'left';
            break;
          case 'right':
            if (snakeDirection !== 'left') newDirection = 'right';
            break;
        }

        if (newDirection) {
          nextDirection = newDirection;
          btn.style.background = '#00ff88';
          setTimeout(() => {
            btn.style.background = 'rgba(0, 255, 136, 0.8)';
          }, 100);
        }
      }, { passive: false });
    });

    // Enhanced swipe controls
    let touchStartX = null;
    let touchStartY = null;
    let touchStartTime = null;
    const minSwipeDistance = 30;
    const maxSwipeTime = 300;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = Date.now();
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!gameRunning || gamePaused || !touchStartX || !touchStartY) return;

      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      const deltaTime = Date.now() - touchStartTime;

      if (deltaTime > maxSwipeTime) return;

      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (distance < minSwipeDistance) return;

      let newDirection = null;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0 && snakeDirection !== 'left') newDirection = 'right';
        else if (deltaX < 0 && snakeDirection !== 'right') newDirection = 'left';
      } else {
        if (deltaY > 0 && snakeDirection !== 'up') newDirection = 'down';
        else if (deltaY < 0 && snakeDirection !== 'down') newDirection = 'up';
      }

      if (newDirection) {
        nextDirection = newDirection;
      }

      touchStartX = null;
      touchStartY = null;
      touchStartTime = null;
    }, { passive: false });

    // Window resize and orientation handling
    window.addEventListener('resize', () => {
      setTimeout(resizeCanvas, 100);
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 200);
    });

    // Initialize settings UI
    function initializeSettings() {
      document.getElementById('showDpad').checked = gameSettings.showDpad;
      document.getElementById('volumeSlider').value = gameSettings.volume;
      document.getElementById('volumeValue').textContent = gameSettings.volume + '%';
      document.getElementById('particleEffects').checked = gameSettings.particleEffects;

      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.difficulty === gameSettings.difficulty);
      });

      // Apply mobile D-pad setting
      const mobileDpad = document.getElementById('mobileDpad');
      if (!gameSettings.showDpad) {
        mobileDpad.classList.add('hidden');
      }
    }

    // Game initialization
    resizeCanvas();
    initGame();
    render();
    initializeSettings();

    // Update best score display
    bestScoreElement.textContent = parseInt(bestScore).toLocaleString();

    // Initial button states
    document.getElementById('pauseBtn').disabled = true;
    document.getElementById('resumeBtn').disabled = true;

    // Auto-start hint
    setTimeout(() => {
      if (!gameRunning) {
        document.getElementById('startBtn').style.animation = 'levelUpPulse 1s ease-in-out infinite';
      }
    }, 2000);
  </script>
</body>

</html>